# Slot_machine

Реализация тестового задания по созданию приложения, эмулирующего вращающиеся барабаны слот-машины.
Графическое изображение реализовано через библиотеку SFML.

## Техническое задание
Приложение должно содержать 3 обязательных графических элемента, показанных на схематичном изображении:

1. барабаны слот-машины;
2. кнопка Start для запуска вращения барабанов;
3. кнопка Stop для остановки вращения барабанов.

### Слот-машина
![Слот-машина](misc/images/example.gif)

### Дополнительные требования
Кроме обязательных элементов приложение должно также иметь:

1. Автоматическую остановку барабанов по таймеру, если кнопка Stop не была нажата.
2. Плавную смену состояний барабанов, то есть барабаны не должны резко начинать и заканчивать
вращение. Также стоит отметить, что мы не требуем сверхточную симуляцию вращения на основе реальных
физических законов.
3. Остановку барабанов только в таких позициях, в которых все символы на барабанах находятся на
одной линии.
4. Как минимум 3 барабана, каждый из которых должен иметь как минимум по 3 символа.
5. Реализация смены режимов игры должна быть основана на машине состояний (state machine).

После остановки барабанов приложение должно осуществить подсчёт выигрыша по любой известной вам
логике. Например, он может быть основан на подсчёте количества одинаковых символов в одной линии.
Необходимо без использования сторонних библиотек реализовать циклическую машину состояний, которая
должна:

- содержать в себе как минимум три состояния (state):
  - ожидание действия игрока, в котором приложение ожидает нажатия на кнопку Start;
  - показ выигрыша, в котором необходимо продемонстрировать расчитанный выигрыш;
  - вращение барабанов, это состояние активно пока другие два неактивны, при желании можно разбить это состояние на более мелкие.
- переходить из одного состояния в другое согласно данной последовательности:
  - ожидание действия игрока;
  - вращение барабанов;
  - показ выигрыша;
  - ожидание действия игрока (новый цикл);
  - и так далее...
- использовать полиморфизм в реализации, то есть классы всех состояний должны иметь общий интерфейс.
